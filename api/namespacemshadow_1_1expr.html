<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Apache SINGA: mshadow::expr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="singa-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Apache SINGA
   </div>
   <div id="projectbrief">A distributed deep learning platform .</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemshadow.html">mshadow</a></li><li class="navelem"><a class="el" href="namespacemshadow_1_1expr.html">expr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mshadow::expr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace for abstract expressions and expressions template, have no dependecy on <a class="el" href="tensor_8h.html" title="header file of tensor data structure and functions covention: this lib requires explicit memory alloc...">tensor.h</a>, These data structure takes no charge in computations, they are only used to define operations and represent expression in a symbolic way  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemshadow_1_1expr_1_1type"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr_1_1type.html">type</a></td></tr>
<tr class="memdesc:namespacemshadow_1_1expr_1_1type"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of expressions <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpEngine.html">ExpEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">expression engine that actually interprets these expressions this is a function template that needed to be implemented for specific expressions  <a href="structmshadow_1_1expr_1_1ExpEngine.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1ContainerExp.html">ContainerExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of all variables, that can be assigned to values  <a href="classmshadow_1_1expr_1_1ContainerExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for expression  <a href="structmshadow_1_1expr_1_1Exp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar expression  <a href="structmshadow_1_1expr_1_1ScalarExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1TransposeExp.html">TransposeExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represent a transpose expression of a container  <a href="structmshadow_1_1expr_1_1TransposeExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix multiplication expression dot( lhs[.T], rhs[.T] )  <a href="structmshadow_1_1expr_1_1DotExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary map expression lhs [op] rhs  <a href="structmshadow_1_1expr_1_1BinaryMapExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary map expression op(src)  <a href="structmshadow_1_1expr_1_1UnaryMapExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1MakeTensorExp.html">MakeTensorExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a general class that allows extension that makes tensors of some shape  <a href="structmshadow_1_1expr_1_1MakeTensorExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1Plan.html">Plan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This part of code gives plan that can be used to carry out execution.  <a href="classmshadow_1_1expr_1_1Plan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1Plan_3_01Tensor_3_01Device_00_01dim_01_4_01_4.html">Plan&lt; Tensor&lt; Device, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1Plan_3_01Tensor_3_01Device_00_011_01_4_01_4.html">Plan&lt; Tensor&lt; Device, 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1Plan_3_01ScalarExp_01_4.html">Plan&lt; ScalarExp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1Plan_3_01BinaryMapExp_3_01OP_00_01TA_00_01TB_00_01etype_01_4_01_4.html">Plan&lt; BinaryMapExp&lt; OP, TA, TB, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1Plan_3_01UnaryMapExp_3_01OP_00_01TA_00_01etype_01_4_01_4.html">Plan&lt; UnaryMapExp&lt; OP, TA, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01MakeTensorExp_3_01SubType_00_01SrcExp_00_01dim_01_4_01_4.html">Plan&lt; MakeTensorExp&lt; SubType, SrcExp, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">static type inference template, used to get the dimension of each expression, if ExpInfo&lt;E&gt;::kDim == -1, this means here are mismatch in expression if ( ExpInfo&lt;E&gt;::kDevMask &amp; <a class="el" href="structmshadow_1_1cpu.html#a57f74b500825e21c0c246ad5b4e5016b" title="device flag number, identifies this device ">cpu::kDevMask</a> ) != 0, this means this expression can be assigned to cpu  <a href="structmshadow_1_1expr_1_1ExpInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpInfo_3_01ScalarExp_01_4.html">ExpInfo&lt; ScalarExp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpInfo_3_01Tensor_3_01Device_00_01dim_01_4_01_4.html">ExpInfo&lt; Tensor&lt; Device, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpInfo_3_01MakeTensorExp_3_01T_00_01SrcExp_00_01dim_01_4_01_4.html">ExpInfo&lt; MakeTensorExp&lt; T, SrcExp, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpInfo_3_01UnaryMapExp_3_01OP_00_01TA_00_01etype_01_4_01_4.html">ExpInfo&lt; UnaryMapExp&lt; OP, TA, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpInfo_3_01BinaryMapExp_3_01OP_00_01TA_00_01TB_00_01etype_01_4_01_4.html">ExpInfo&lt; BinaryMapExp&lt; OP, TA, TB, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1TypeCheck.html">TypeCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to do type check  <a href="structmshadow_1_1expr_1_1TypeCheck.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1TypeCheckPass.html">TypeCheckPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1TypeCheckPass_3_01false_01_4.html">TypeCheckPass&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1TypeCheckPass_3_01true_01_4.html">TypeCheckPass&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ShapeCheck.html">ShapeCheck</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ShapeCheck_3_01dim_00_01ScalarExp_01_4.html">ShapeCheck&lt; dim, ScalarExp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ShapeCheck_3_01dim_00_01Tensor_3_01Device_00_01dim_01_4_01_4.html">ShapeCheck&lt; dim, Tensor&lt; Device, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ShapeCheck_3_01dim_00_01MakeTensorExp_3_01T_00_01SrcExp_00_01dim_01_4_01_4.html">ShapeCheck&lt; dim, MakeTensorExp&lt; T, SrcExp, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ShapeCheck_3_01dim_00_01UnaryMapExp_3_01OP_00_01TA_00_01etype_01_4_01_4.html">ShapeCheck&lt; dim, UnaryMapExp&lt; OP, TA, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ShapeCheck_3_01dim_00_01BinaryMapExp_3_01OP_00_01TA_00_01TB_00_01etype_01_4_01_4.html">ShapeCheck&lt; dim, BinaryMapExp&lt; OP, TA, TB, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1DotEngine.html">DotEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1BLASEngine.html">BLASEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1BLASEngine_3_01cpu_01_4.html">BLASEngine&lt; cpu &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1BLASEngine_3_01gpu_01_4.html">BLASEngine&lt; gpu &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1DotEngine_3_01SV_00_01xpu_00_012_00_012_00_012_00_01transpose__left_00_01transpose__right_01_4.html">DotEngine&lt; SV, xpu, 2, 2, 2, transpose_left, transpose_right &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1DotEngine_3_01SV_00_01xpu_00_011_00_011_00_012_00_01false_00_01transpose__right_01_4.html">DotEngine&lt; SV, xpu, 1, 1, 2, false, transpose_right &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1DotEngine_3_01SV_00_01xpu_00_012_00_011_00_011_00_01true_00_01false_01_4.html">DotEngine&lt; SV, xpu, 2, 1, 1, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpComplexEngine.html">ExpComplexEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">some engine that evaluate complex expression  <a href="structmshadow_1_1expr_1_1ExpComplexEngine.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpEngine_3_01SV_00_01Tensor_3_01Device_00_01dim_01_4_01_4.html">ExpEngine&lt; SV, Tensor&lt; Device, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpComplexEngine_3_01SV_00_01Device_00_01dim_00_01DotExp_3_01Tensor_3_0d2749ba7c02c3255b394f980e81ccfd3.html">ExpComplexEngine&lt; SV, Device, dim, DotExp&lt; Tensor&lt; Device, ldim &gt;, Tensor&lt; Device, rdim &gt;, ltrans, rtrans &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Broadcast1DExp.html">Broadcast1DExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">broadcast Tensor1D into a higher dimension <a class="el" href="structmshadow_1_1Tensor.html" title="general tensor ">Tensor</a> input: <a class="el" href="structmshadow_1_1Tensor_3_01Device_00_011_01_4.html">Tensor&lt;Device,1&gt;</a>: ishape[0] output: Tensor&lt;Device,dimdst&gt; : oshape[dimcast] = ishape[0]  <a href="structmshadow_1_1expr_1_1Broadcast1DExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1UnpackPatchToColXExp.html">UnpackPatchToColXExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">unpack local (overlap) patches of image to column of mat, can be used to implement convolution, this expression allow unpack of a batch this is a version support unpacking multiple images after getting unpacked mat, we can use: output = dot( weight, mat ) to get covolved results, the relations:  <a href="structmshadow_1_1expr_1_1UnpackPatchToColXExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1PackColToPatchXExp.html">PackColToPatchXExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse operation of UnpackPatchToCol, used to backprop gradient back this is a version supporting multiple images  <a href="structmshadow_1_1expr_1_1PackColToPatchXExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ReshapeExp.html">ReshapeExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reshape the content to another shape input: Tensor&lt;Device,dimsrc&gt;: ishape output: Tensor&lt;Device,dimdst&gt; ishape.Size() == oshape.Size()  <a href="structmshadow_1_1expr_1_1ReshapeExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SwapAxisExp.html">SwapAxisExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap two axis of a tensor input: Tensor&lt;Device,dim&gt;: ishape output: Tensor&lt;Device,dimdst&gt; oshape[a1],oshape[a2] = ishape[a2],oshape[a1]  <a href="structmshadow_1_1expr_1_1SwapAxisExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reduction to 1 dimension tensor input: Tensor&lt;Device,k&gt;: ishape output: <a class="el" href="structmshadow_1_1Tensor_3_01Device_00_011_01_4.html">Tensor&lt;Device,1&gt;</a> shape[0] = ishape[dimkeep];  <a href="structmshadow_1_1expr_1_1ReduceTo1DExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1PoolingExp.html">PoolingExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pooling expression, do reduction over local patches of a image  <a href="structmshadow_1_1expr_1_1PoolingExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1UnPoolingExp.html">UnPoolingExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">unpooling expr reverse operation of pooling, used to pass gradient back  <a href="structmshadow_1_1expr_1_1UnPoolingExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1PaddingExp.html">PaddingExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">padding expression, pad a image with zeros  <a href="structmshadow_1_1expr_1_1PaddingExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1CroppingExp.html">CroppingExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">crop expression, cut off the boundary region, reverse operation of padding  <a href="structmshadow_1_1expr_1_1CroppingExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1MirroringExp.html">MirroringExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror expression, mirror a image in width  <a href="structmshadow_1_1expr_1_1MirroringExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ChannelPoolingExp.html">ChannelPoolingExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel pooling expression, do reduction over (local nearby) channels, used to implement local response normalization  <a href="structmshadow_1_1expr_1_1ChannelPoolingExp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpComplexEngine_3_01SV_00_01Device_00_011_00_01ReduceTo1DExp_3_01ETypeff38f24c2af0b97a027119d64099704c.html">ExpComplexEngine&lt; SV, Device, 1, ReduceTo1DExp&lt; EType, Reducer, dimkeep &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1ExpComplexEngine_3_01SV_00_01Device_00_011_00_01ReduceTo1DExp_3_01EType_00_01Reducer_00_010_01_4_01_4.html">ExpComplexEngine&lt; SV, Device, 1, ReduceTo1DExp&lt; EType, Reducer, 0 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01Broadcast1DExp_3_01Device_00_01dimdst_00_01dimcast_01_4_01_4.html">Plan&lt; Broadcast1DExp&lt; Device, dimdst, dimcast &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">execution plan of <a class="el" href="structmshadow_1_1expr_1_1Broadcast1DExp.html" title="broadcast Tensor1D into a higher dimension Tensor input: Tensor&lt;Device,1&gt;: ishape[0] output: Tensor&lt;D...">Broadcast1DExp</a>  <a href="structmshadow_1_1expr_1_1Plan_3_01Broadcast1DExp_3_01Device_00_01dimdst_00_01dimcast_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01Broadcast1DExp_3_01Device_00_01dimdst_00_010_01_4_01_4.html">Plan&lt; Broadcast1DExp&lt; Device, dimdst, 0 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">execution plan of <a class="el" href="structmshadow_1_1expr_1_1Broadcast1DExp.html" title="broadcast Tensor1D into a higher dimension Tensor input: Tensor&lt;Device,1&gt;: ishape[0] output: Tensor&lt;D...">Broadcast1DExp</a>  <a href="structmshadow_1_1expr_1_1Plan_3_01Broadcast1DExp_3_01Device_00_01dimdst_00_010_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01UnpackPatchToColXExp_3_01SrcExp_00_01srcdim_01_4_01_4.html">Plan&lt; UnpackPatchToColXExp&lt; SrcExp, srcdim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01PackColToPatchXExp_3_01Device_00_01dstdim_01_4_01_4.html">Plan&lt; PackColToPatchXExp&lt; Device, dstdim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01ReshapeExp_3_01SrcExp_00_01dimdst_00_01dimsrc_01_4_01_4.html">Plan&lt; ReshapeExp&lt; SrcExp, dimdst, dimsrc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01ReshapeExp_3_01SrcExp_00_01dimdst_00_011_01_4_01_4.html">Plan&lt; ReshapeExp&lt; SrcExp, dimdst, 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01SwapAxisExp_3_01SrcExp_00_01dimsrc_00_01a1_00_01a2_01_4_01_4.html">Plan&lt; SwapAxisExp&lt; SrcExp, dimsrc, a1, a2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01SwapAxisExp_3_01SrcExp_00_01dimsrc_00_010_00_01a2_01_4_01_4.html">Plan&lt; SwapAxisExp&lt; SrcExp, dimsrc, 0, a2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01PoolingExp_3_01Reducer_00_01SrcExp_00_01srcdim_01_4_01_4.html">Plan&lt; PoolingExp&lt; Reducer, SrcExp, srcdim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01UnPoolingExp_3_01Reducer_00_01Device_01_4_01_4.html">Plan&lt; UnPoolingExp&lt; Reducer, Device &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01PaddingExp_3_01SrcExp_00_01srcdim_01_4_01_4.html">Plan&lt; PaddingExp&lt; SrcExp, srcdim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01CroppingExp_3_01SrcExp_00_01srcdim_01_4_01_4.html">Plan&lt; CroppingExp&lt; SrcExp, srcdim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01MirroringExp_3_01SrcExp_00_01srcdim_01_4_01_4.html">Plan&lt; MirroringExp&lt; SrcExp, srcdim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1Plan_3_01ChannelPoolingExp_3_01Reducer_00_01SrcExp_00_01srcdim_01_4_01_4.html">Plan&lt; ChannelPoolingExp&lt; Reducer, SrcExp, srcdim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSECheck_3_01Broadcast1DExp_3_01cpu_00_01dimdst_00_010_01_4_01_4.html">SSECheck&lt; Broadcast1DExp&lt; cpu, dimdst, 0 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSEAlignCheck_3_012_00_01Broadcast1DExp_3_01cpu_00_01dimdst_00_010_01_4_01_4.html">SSEAlignCheck&lt; 2, Broadcast1DExp&lt; cpu, dimdst, 0 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan_3_01Broadcast1DExp_3_01cpu_00_01dimdst_00_010_01_4_01_4.html">SSEPlan&lt; Broadcast1DExp&lt; cpu, dimdst, 0 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan.html">SSEPlan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan_3_01Tensor_3_01Device_00_01dim_01_4_01_4.html">SSEPlan&lt; Tensor&lt; Device, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan_3_01ScalarExp_01_4.html">SSEPlan&lt; ScalarExp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan_3_01BinaryMapExp_3_01OP_00_01TA_00_01TB_00_01etype_01_4_01_4.html">SSEPlan&lt; BinaryMapExp&lt; OP, TA, TB, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan_3_01UnaryMapExp_3_01OP_00_01TA_00_01etype_01_4_01_4.html">SSEPlan&lt; UnaryMapExp&lt; OP, TA, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSECheck.html">SSECheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">static check sse enable if a expression E can not be evaluated using sse, then kPass = false  <a href="structmshadow_1_1expr_1_1SSECheck.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSECheck_3_01ScalarExp_01_4.html">SSECheck&lt; ScalarExp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSECheck_3_01Tensor_3_01cpu_00_01dim_01_4_01_4.html">SSECheck&lt; Tensor&lt; cpu, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSECheck_3_01UnaryMapExp_3_01OP_00_01TA_00_01etype_01_4_01_4.html">SSECheck&lt; UnaryMapExp&lt; OP, TA, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSECheck_3_01BinaryMapExp_3_01OP_00_01TA_00_01TB_00_01etype_01_4_01_4.html">SSECheck&lt; BinaryMapExp&lt; OP, TA, TB, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSEAlignCheck.html">SSEAlignCheck</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSEAlignCheck_3_01dim_00_01ScalarExp_01_4.html">SSEAlignCheck&lt; dim, ScalarExp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSEAlignCheck_3_01dim_00_01Tensor_3_01cpu_00_01dim_01_4_01_4.html">SSEAlignCheck&lt; dim, Tensor&lt; cpu, dim &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSEAlignCheck_3_01dim_00_01UnaryMapExp_3_01OP_00_01TA_00_01etype_01_4_01_4.html">SSEAlignCheck&lt; dim, UnaryMapExp&lt; OP, TA, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmshadow_1_1expr_1_1SSEAlignCheck_3_01dim_00_01BinaryMapExp_3_01OP_00_01TA_00_01TB_00_01etype_01_4_01_4.html">SSEAlignCheck&lt; dim, BinaryMapExp&lt; OP, TA, TB, etype &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afe9142ec1b06f57c2ccd1e6e5988a29a"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe9142ec1b06f57c2ccd1e6e5988a29a"></a>
template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:afe9142ec1b06f57c2ccd1e6e5988a29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, false, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#afe9142ec1b06f57c2ccd1e6e5988a29a">dot</a> (const <a class="el" href="classmshadow_1_1expr_1_1ContainerExp.html">ContainerExp</a>&lt; TA &gt; &amp;lhs, const <a class="el" href="classmshadow_1_1expr_1_1ContainerExp.html">ContainerExp</a>&lt; TB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afe9142ec1b06f57c2ccd1e6e5988a29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot operator def <br/></td></tr>
<tr class="separator:afe9142ec1b06f57c2ccd1e6e5988a29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3dce2a09e40f3c5fd99640ef379da8"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd3dce2a09e40f3c5fd99640ef379da8"></a>
template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:afd3dce2a09e40f3c5fd99640ef379da8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, true, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#afd3dce2a09e40f3c5fd99640ef379da8">dot</a> (const <a class="el" href="structmshadow_1_1expr_1_1TransposeExp.html">TransposeExp</a>&lt; TA &gt; &amp;lhs, const <a class="el" href="classmshadow_1_1expr_1_1ContainerExp.html">ContainerExp</a>&lt; TB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afd3dce2a09e40f3c5fd99640ef379da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot operator def <br/></td></tr>
<tr class="separator:afd3dce2a09e40f3c5fd99640ef379da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f79951567787063c66768c3ffdd76"><td class="memTemplParams" colspan="2"><a class="anchor" id="a405f79951567787063c66768c3ffdd76"></a>
template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a405f79951567787063c66768c3ffdd76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, false, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a405f79951567787063c66768c3ffdd76">dot</a> (const <a class="el" href="classmshadow_1_1expr_1_1ContainerExp.html">ContainerExp</a>&lt; TA &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1TransposeExp.html">TransposeExp</a>&lt; TB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a405f79951567787063c66768c3ffdd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot operator def <br/></td></tr>
<tr class="separator:a405f79951567787063c66768c3ffdd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43d079e8b27b2511080f0c8fd0ed88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c43d079e8b27b2511080f0c8fd0ed88"></a>
template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a7c43d079e8b27b2511080f0c8fd0ed88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, true, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a7c43d079e8b27b2511080f0c8fd0ed88">dot</a> (const <a class="el" href="structmshadow_1_1expr_1_1TransposeExp.html">TransposeExp</a>&lt; TA &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1TransposeExp.html">TransposeExp</a>&lt; TB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7c43d079e8b27b2511080f0c8fd0ed88"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot operator def <br/></td></tr>
<tr class="separator:a7c43d079e8b27b2511080f0c8fd0ed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f9bd839c51da47506bc2506f1b7c55"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1f9bd839c51da47506bc2506f1b7c55"></a>
template&lt;typename TA , typename TB , bool ltrans, bool rtrans&gt; </td></tr>
<tr class="memitem:ad1f9bd839c51da47506bc2506f1b7c55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, ltrans, rtrans &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#ad1f9bd839c51da47506bc2506f1b7c55">operator*</a> (const <a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, ltrans, rtrans &gt; &amp;lhs, <a class="el" href="namespacemshadow.html#a6b8da350a039195525801b23b3a2d942">real_t</a> rhs)</td></tr>
<tr class="memdesc:ad1f9bd839c51da47506bc2506f1b7c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot operator def <br/></td></tr>
<tr class="separator:ad1f9bd839c51da47506bc2506f1b7c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e99d36a7426a567d5a03b2aff9017e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e99d36a7426a567d5a03b2aff9017e6"></a>
template&lt;typename TA , typename TB , bool ltrans, bool rtrans&gt; </td></tr>
<tr class="memitem:a1e99d36a7426a567d5a03b2aff9017e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, ltrans, rtrans &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a1e99d36a7426a567d5a03b2aff9017e6">operator*</a> (<a class="el" href="namespacemshadow.html#a6b8da350a039195525801b23b3a2d942">real_t</a> lhs, const <a class="el" href="structmshadow_1_1expr_1_1DotExp.html">DotExp</a>&lt; TA, TB, ltrans, rtrans &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1e99d36a7426a567d5a03b2aff9017e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale of dot operation <br/></td></tr>
<tr class="separator:a1e99d36a7426a567d5a03b2aff9017e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d25bb97805c7f8504446abb5bd15f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a58d25bb97805c7f8504446abb5bd15f0"></a>
template&lt;typename OP , typename TA , typename TB , int ta, int tb&gt; </td></tr>
<tr class="memitem:a58d25bb97805c7f8504446abb5bd15f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, TA, TB,(ta|tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a58d25bb97805c7f8504446abb5bd15f0">MakeExp</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a58d25bb97805c7f8504446abb5bd15f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">make expression <br/></td></tr>
<tr class="separator:a58d25bb97805c7f8504446abb5bd15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694976236618fc4e22c5ccd752981589"><td class="memTemplParams" colspan="2">template&lt;typename OP , typename TA , typename TB , int ta, int tb&gt; </td></tr>
<tr class="memitem:a694976236618fc4e22c5ccd752981589"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, TA, TB,(ta|tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a694976236618fc4e22c5ccd752981589">F</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a694976236618fc4e22c5ccd752981589"><td class="mdescLeft">&#160;</td><td class="mdescRight">short hand for MakeExp, usage F&lt;op&gt;(lhs, rhs). create a binary operation expression  <a href="#a694976236618fc4e22c5ccd752981589">More...</a><br/></td></tr>
<tr class="separator:a694976236618fc4e22c5ccd752981589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0b5dba6bce6dfa8fef3283fd543a73"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2a0b5dba6bce6dfa8fef3283fd543a73"></a>
template&lt;typename OP , typename TA , int ta&gt; </td></tr>
<tr class="memitem:a2a0b5dba6bce6dfa8fef3283fd543a73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, TA, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a2a0b5dba6bce6dfa8fef3283fd543a73">F</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2a0b5dba6bce6dfa8fef3283fd543a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload for const <br/></td></tr>
<tr class="separator:a2a0b5dba6bce6dfa8fef3283fd543a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3134c0435cce3dcf359808e0ee657a72"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3134c0435cce3dcf359808e0ee657a72"></a>
template&lt;typename OP , typename TB , int tb&gt; </td></tr>
<tr class="memitem:a3134c0435cce3dcf359808e0ee657a72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>, <br class="typebreak"/>
TB,(tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a3134c0435cce3dcf359808e0ee657a72">F</a> (const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3134c0435cce3dcf359808e0ee657a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload for const <br/></td></tr>
<tr class="separator:a3134c0435cce3dcf359808e0ee657a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e6288e5476eb79f75e081c5938390"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a2e6288e5476eb79f75e081c5938390"></a>
template&lt;typename TA , typename TB , int ta, int tb&gt; </td></tr>
<tr class="memitem:a3a2e6288e5476eb79f75e081c5938390"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1plus.html">op::plus</a>, TA, TB,(ta|tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a3a2e6288e5476eb79f75e081c5938390">operator+</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3a2e6288e5476eb79f75e081c5938390"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a3a2e6288e5476eb79f75e081c5938390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010bfdbb194d9e933c0b875f3848ad83"><td class="memTemplParams" colspan="2"><a class="anchor" id="a010bfdbb194d9e933c0b875f3848ad83"></a>
template&lt;typename TA , typename TB , int ta, int tb&gt; </td></tr>
<tr class="memitem:a010bfdbb194d9e933c0b875f3848ad83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1minus.html">op::minus</a>, TA, <br class="typebreak"/>
TB,(ta|tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a010bfdbb194d9e933c0b875f3848ad83">operator-</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a010bfdbb194d9e933c0b875f3848ad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a010bfdbb194d9e933c0b875f3848ad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e6469bee7d05e6c4a6a124d30461dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67e6469bee7d05e6c4a6a124d30461dc"></a>
template&lt;typename TA , typename TB , int ta, int tb&gt; </td></tr>
<tr class="memitem:a67e6469bee7d05e6c4a6a124d30461dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1mul.html">op::mul</a>, TA, TB,(ta|tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a67e6469bee7d05e6c4a6a124d30461dc">operator*</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a67e6469bee7d05e6c4a6a124d30461dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a67e6469bee7d05e6c4a6a124d30461dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe6ec21b879831361a8160ae105b6ab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0fe6ec21b879831361a8160ae105b6ab"></a>
template&lt;typename TA , typename TB , int ta, int tb&gt; </td></tr>
<tr class="memitem:a0fe6ec21b879831361a8160ae105b6ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1div.html">op::div</a>, TA, TB,(ta|tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a0fe6ec21b879831361a8160ae105b6ab">operator/</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0fe6ec21b879831361a8160ae105b6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a0fe6ec21b879831361a8160ae105b6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecda7975d345e7de3b3afd10eb3641ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="aecda7975d345e7de3b3afd10eb3641ad"></a>
template&lt;typename TA , int ta&gt; </td></tr>
<tr class="memitem:aecda7975d345e7de3b3afd10eb3641ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1plus.html">op::plus</a>, TA, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#aecda7975d345e7de3b3afd10eb3641ad">operator+</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;rhs)</td></tr>
<tr class="memdesc:aecda7975d345e7de3b3afd10eb3641ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:aecda7975d345e7de3b3afd10eb3641ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654551976a48381ef230917dd5371ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3654551976a48381ef230917dd5371ca"></a>
template&lt;typename TA , int ta&gt; </td></tr>
<tr class="memitem:a3654551976a48381ef230917dd5371ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1minus.html">op::minus</a>, TA, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a3654551976a48381ef230917dd5371ca">operator-</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;rhs)</td></tr>
<tr class="memdesc:a3654551976a48381ef230917dd5371ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a3654551976a48381ef230917dd5371ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c92502cabee4e4ead569df86fc3f80"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2c92502cabee4e4ead569df86fc3f80"></a>
template&lt;typename TA , int ta&gt; </td></tr>
<tr class="memitem:af2c92502cabee4e4ead569df86fc3f80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1mul.html">op::mul</a>, TA, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#af2c92502cabee4e4ead569df86fc3f80">operator*</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;rhs)</td></tr>
<tr class="memdesc:af2c92502cabee4e4ead569df86fc3f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:af2c92502cabee4e4ead569df86fc3f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fe899c72cf2c4b932b0e5f18490632"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34fe899c72cf2c4b932b0e5f18490632"></a>
template&lt;typename TA , int ta&gt; </td></tr>
<tr class="memitem:a34fe899c72cf2c4b932b0e5f18490632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1div.html">op::div</a>, TA, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a34fe899c72cf2c4b932b0e5f18490632">operator/</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;rhs)</td></tr>
<tr class="memdesc:a34fe899c72cf2c4b932b0e5f18490632"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a34fe899c72cf2c4b932b0e5f18490632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b467406d0beb7b4acdbe14045cb751e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b467406d0beb7b4acdbe14045cb751e"></a>
template&lt;typename TB , int tb&gt; </td></tr>
<tr class="memitem:a6b467406d0beb7b4acdbe14045cb751e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1plus.html">op::plus</a>, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>, TB,(tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a6b467406d0beb7b4acdbe14045cb751e">operator+</a> (const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6b467406d0beb7b4acdbe14045cb751e"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a6b467406d0beb7b4acdbe14045cb751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6ab2f3c3eab5490f2d43ecbe11c9b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd6ab2f3c3eab5490f2d43ecbe11c9b0"></a>
template&lt;typename TB , int tb&gt; </td></tr>
<tr class="memitem:afd6ab2f3c3eab5490f2d43ecbe11c9b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1minus.html">op::minus</a>, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>, TB,(tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#afd6ab2f3c3eab5490f2d43ecbe11c9b0">operator-</a> (const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afd6ab2f3c3eab5490f2d43ecbe11c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:afd6ab2f3c3eab5490f2d43ecbe11c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8294326da2e624d55e6c964b3fda817"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8294326da2e624d55e6c964b3fda817"></a>
template&lt;typename TB , int tb&gt; </td></tr>
<tr class="memitem:ae8294326da2e624d55e6c964b3fda817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1mul.html">op::mul</a>, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>, TB,(tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#ae8294326da2e624d55e6c964b3fda817">operator*</a> (const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae8294326da2e624d55e6c964b3fda817"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:ae8294326da2e624d55e6c964b3fda817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edfb10d1ae75d9a84a22e9e5883d2c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7edfb10d1ae75d9a84a22e9e5883d2c4"></a>
template&lt;typename TB , int tb&gt; </td></tr>
<tr class="memitem:a7edfb10d1ae75d9a84a22e9e5883d2c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; <a class="el" href="structmshadow_1_1op_1_1div.html">op::div</a>, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a>, TB,(tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a7edfb10d1ae75d9a84a22e9e5883d2c4">operator/</a> (const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;lhs, const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TB, tb &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7edfb10d1ae75d9a84a22e9e5883d2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a7edfb10d1ae75d9a84a22e9e5883d2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ecb60b6450c923a388c71dc973cb39"><td class="memTemplParams" colspan="2"><a class="anchor" id="a31ecb60b6450c923a388c71dc973cb39"></a>
template&lt;typename OP , typename TA , int ta&gt; </td></tr>
<tr class="memitem:a31ecb60b6450c923a388c71dc973cb39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a>&lt; OP, TA,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a31ecb60b6450c923a388c71dc973cb39">MakeExp</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;src)</td></tr>
<tr class="memdesc:a31ecb60b6450c923a388c71dc973cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">make expression <br/></td></tr>
<tr class="separator:a31ecb60b6450c923a388c71dc973cb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bd250e50a00def5ea9231596645044"><td class="memTemplParams" colspan="2">template&lt;typename OP , typename TA , int ta&gt; </td></tr>
<tr class="memitem:af7bd250e50a00def5ea9231596645044"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a>&lt; OP, TA,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#af7bd250e50a00def5ea9231596645044">F</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; TA, ta &gt; &amp;src)</td></tr>
<tr class="memdesc:af7bd250e50a00def5ea9231596645044"><td class="mdescLeft">&#160;</td><td class="mdescRight">short hand for MakeExp, usage F&lt;op&gt;(src), create a unary operation expression  <a href="#af7bd250e50a00def5ea9231596645044">More...</a><br/></td></tr>
<tr class="separator:af7bd250e50a00def5ea9231596645044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0267ee0b3dd244f2edde23cc8b9520cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0267ee0b3dd244f2edde23cc8b9520cb"></a>
template&lt;typename OP , typename TA , typename TB , int etype&gt; </td></tr>
<tr class="memitem:a0267ee0b3dd244f2edde23cc8b9520cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1Plan.html">Plan</a>&lt; <a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, TA, TB, <br class="typebreak"/>
etype &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakePlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, TA, TB, etype &gt; &amp;e)</td></tr>
<tr class="separator:a0267ee0b3dd244f2edde23cc8b9520cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5159a77cacb0e6eef22092291ccbc0fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5159a77cacb0e6eef22092291ccbc0fc"></a>
<a class="el" href="classmshadow_1_1expr_1_1Plan.html">Plan</a>&lt; <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakePlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;e)</td></tr>
<tr class="separator:a5159a77cacb0e6eef22092291ccbc0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd9ba71a1f6fc95a0e6ec9b389907b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="accd9ba71a1f6fc95a0e6ec9b389907b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:accd9ba71a1f6fc95a0e6ec9b389907b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1Plan.html">Plan</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakePlan</b> (const <a class="el" href="classmshadow_1_1expr_1_1ContainerExp.html">ContainerExp</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="separator:accd9ba71a1f6fc95a0e6ec9b389907b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd7a8d3211a46d84e0cfeab0ec46026"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5cd7a8d3211a46d84e0cfeab0ec46026"></a>
template&lt;typename T , typename SrcExp , int dim&gt; </td></tr>
<tr class="memitem:a5cd7a8d3211a46d84e0cfeab0ec46026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1Plan.html">Plan</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakePlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1MakeTensorExp.html">MakeTensorExp</a>&lt; T, SrcExp, dim &gt; &amp;e)</td></tr>
<tr class="separator:a5cd7a8d3211a46d84e0cfeab0ec46026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cc19e68bc14dad961424760b5c8140"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01cc19e68bc14dad961424760b5c8140"></a>
template&lt;typename OP , typename TA , int etype&gt; </td></tr>
<tr class="memitem:a01cc19e68bc14dad961424760b5c8140"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1Plan.html">Plan</a>&lt; <a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a>&lt; OP, TA, <br class="typebreak"/>
etype &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakePlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a>&lt; OP, TA, etype &gt; &amp;e)</td></tr>
<tr class="separator:a01cc19e68bc14dad961424760b5c8140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bc548545a9c8f04ae6b0223bd085c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14bc548545a9c8f04ae6b0223bd085c7"></a>
template&lt;typename E , typename R , int d&gt; </td></tr>
<tr class="memitem:a14bc548545a9c8f04ae6b0223bd085c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt; E, R, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a14bc548545a9c8f04ae6b0223bd085c7">operator*</a> (const <a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt; E, R, d &gt; &amp;e, <a class="el" href="namespacemshadow.html#a6b8da350a039195525801b23b3a2d942">real_t</a> scale)</td></tr>
<tr class="memdesc:a14bc548545a9c8f04ae6b0223bd085c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a14bc548545a9c8f04ae6b0223bd085c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219acd60ae4a8b737c86c49045a98692"><td class="memTemplParams" colspan="2"><a class="anchor" id="a219acd60ae4a8b737c86c49045a98692"></a>
template&lt;typename E , typename R , int d&gt; </td></tr>
<tr class="memitem:a219acd60ae4a8b737c86c49045a98692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt; E, R, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a219acd60ae4a8b737c86c49045a98692">operator*</a> (<a class="el" href="namespacemshadow.html#a6b8da350a039195525801b23b3a2d942">real_t</a> scale, const <a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt; E, R, d &gt; &amp;e)</td></tr>
<tr class="memdesc:a219acd60ae4a8b737c86c49045a98692"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator overload <br/></td></tr>
<tr class="separator:a219acd60ae4a8b737c86c49045a98692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd375ac36285f66ca4b3b77dfa93bab"><td class="memTemplParams" colspan="2">template&lt;int dimcast, typename Device , int dimdst&gt; </td></tr>
<tr class="memitem:adbd375ac36285f66ca4b3b77dfa93bab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1Broadcast1DExp.html">Broadcast1DExp</a>&lt; Device, dimdst, <br class="typebreak"/>
dimcast &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#adbd375ac36285f66ca4b3b77dfa93bab">broadcast</a> (const <a class="el" href="structmshadow_1_1Tensor.html">Tensor</a>&lt; Device, 1 &gt; &amp;src, <a class="el" href="structmshadow_1_1Shape.html">Shape</a>&lt; dimdst &gt; shape)</td></tr>
<tr class="memdesc:adbd375ac36285f66ca4b3b77dfa93bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">a expression that replicate a 1 dimension tensor in dimension dimcast  <a href="#adbd375ac36285f66ca4b3b77dfa93bab">More...</a><br/></td></tr>
<tr class="separator:adbd375ac36285f66ca4b3b77dfa93bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2f6a31c6d0fdfcf522e8928f3ce35"><td class="memTemplParams" colspan="2">template&lt;typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:a91f2f6a31c6d0fdfcf522e8928f3ce35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1UnpackPatchToColXExp.html">UnpackPatchToColXExp</a>&lt; SrcExp, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a91f2f6a31c6d0fdfcf522e8928f3ce35">unpack_patch2col</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;img, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> psize, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> pstride)</td></tr>
<tr class="memdesc:a91f2f6a31c6d0fdfcf522e8928f3ce35"><td class="mdescLeft">&#160;</td><td class="mdescRight">unpack local (overlap) patches of image to column of mat, can be used to implement convolution after getting unpacked mat, we can use: output = dot( weight, mat ) to get covolved results, the relations:  <a href="#a91f2f6a31c6d0fdfcf522e8928f3ce35">More...</a><br/></td></tr>
<tr class="separator:a91f2f6a31c6d0fdfcf522e8928f3ce35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e2eb3b1d959701ac1740a5d98142a5"><td class="memTemplParams" colspan="2">template&lt;typename Device , int dstdim&gt; </td></tr>
<tr class="memitem:aa0e2eb3b1d959701ac1740a5d98142a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1PackColToPatchXExp.html">PackColToPatchXExp</a>&lt; Device, <br class="typebreak"/>
dstdim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#aa0e2eb3b1d959701ac1740a5d98142a5">pack_col2patch</a> (const <a class="el" href="structmshadow_1_1Tensor.html">Tensor</a>&lt; Device, 2 &gt; &amp;mat, <a class="el" href="structmshadow_1_1Shape.html">Shape</a>&lt; dstdim &gt; imshape, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> psize, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> pstride)</td></tr>
<tr class="memdesc:aa0e2eb3b1d959701ac1740a5d98142a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse operation of pack_col2patch, can be used to implement deconvolution  <a href="#aa0e2eb3b1d959701ac1740a5d98142a5">More...</a><br/></td></tr>
<tr class="separator:aa0e2eb3b1d959701ac1740a5d98142a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65c95414492a64bb51dbd0710fd9c7"><td class="memTemplParams" colspan="2">template&lt;typename SrcExp , int etype, int dimdst&gt; </td></tr>
<tr class="memitem:a5a65c95414492a64bb51dbd0710fd9c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1ReshapeExp.html">ReshapeExp</a>&lt; SrcExp, dimdst, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a5a65c95414492a64bb51dbd0710fd9c7">reshape</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src, <a class="el" href="structmshadow_1_1Shape.html">Shape</a>&lt; dimdst &gt; oshape)</td></tr>
<tr class="memdesc:a5a65c95414492a64bb51dbd0710fd9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a expression that reshapes a tensor to another shape  <a href="#a5a65c95414492a64bb51dbd0710fd9c7">More...</a><br/></td></tr>
<tr class="separator:a5a65c95414492a64bb51dbd0710fd9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad222b7d78cd6b1e9fe4fe31fe837d88a"><td class="memTemplParams" colspan="2">template&lt;int a1, int a2, typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:ad222b7d78cd6b1e9fe4fe31fe837d88a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1SwapAxisExp.html">SwapAxisExp</a>&lt; SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a><br class="typebreak"/>
&lt; SrcExp &gt;::kDim, a1, a2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#ad222b7d78cd6b1e9fe4fe31fe837d88a">swapaxis</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src)</td></tr>
<tr class="memdesc:ad222b7d78cd6b1e9fe4fe31fe837d88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a expression that reshapes a tensor to another shape  <a href="#ad222b7d78cd6b1e9fe4fe31fe837d88a">More...</a><br/></td></tr>
<tr class="separator:ad222b7d78cd6b1e9fe4fe31fe837d88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c28af37c1dd0b2efee2bb896d628803"><td class="memTemplParams" colspan="2">template&lt;int dimkeep, typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:a3c28af37c1dd0b2efee2bb896d628803"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt; SrcExp, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1red_1_1sum.html">red::sum</a>, dimkeep &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a3c28af37c1dd0b2efee2bb896d628803">sumall_except_dim</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;exp)</td></tr>
<tr class="memdesc:a3c28af37c1dd0b2efee2bb896d628803"><td class="mdescLeft">&#160;</td><td class="mdescRight">a sum over all dimensions, except dimkeep  <a href="#a3c28af37c1dd0b2efee2bb896d628803">More...</a><br/></td></tr>
<tr class="separator:a3c28af37c1dd0b2efee2bb896d628803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcba0398ae5e8897b0803e80fa4df7ae"><td class="memTemplParams" colspan="2">template&lt;typename Reducer , typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:afcba0398ae5e8897b0803e80fa4df7ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1PoolingExp.html">PoolingExp</a>&lt; Reducer, SrcExp, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#afcba0398ae5e8897b0803e80fa4df7ae">pool</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> ksize, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> kstride)</td></tr>
<tr class="memdesc:afcba0398ae5e8897b0803e80fa4df7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">pooling subregion results together  <a href="#afcba0398ae5e8897b0803e80fa4df7ae">More...</a><br/></td></tr>
<tr class="separator:afcba0398ae5e8897b0803e80fa4df7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ebccc287df237b904ad73ea19b6eb0"><td class="memTemplParams" colspan="2">template&lt;typename Reducer , typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:af9ebccc287df237b904ad73ea19b6eb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1PoolingExp.html">PoolingExp</a>&lt; Reducer, SrcExp, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#af9ebccc287df237b904ad73ea19b6eb0">pool</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src, <a class="el" href="structmshadow_1_1Shape.html">Shape</a>&lt; 2 &gt; pshape, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> ksize, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> kstride)</td></tr>
<tr class="memdesc:af9ebccc287df237b904ad73ea19b6eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as pool, except the output shape is specified by pshape  <a href="#af9ebccc287df237b904ad73ea19b6eb0">More...</a><br/></td></tr>
<tr class="separator:af9ebccc287df237b904ad73ea19b6eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9122d3e29b798bf56ea541a1c8a640f3"><td class="memTemplParams" colspan="2">template&lt;typename Reducer , typename Device &gt; </td></tr>
<tr class="memitem:a9122d3e29b798bf56ea541a1c8a640f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1UnPoolingExp.html">UnPoolingExp</a>&lt; Reducer, Device &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a9122d3e29b798bf56ea541a1c8a640f3">unpool</a> (const <a class="el" href="structmshadow_1_1Tensor.html">Tensor</a>&lt; Device, 4 &gt; &amp;data_src, const <a class="el" href="structmshadow_1_1Tensor.html">Tensor</a>&lt; Device, 4 &gt; &amp;data_pooled, const <a class="el" href="structmshadow_1_1Tensor.html">Tensor</a>&lt; Device, 4 &gt; &amp;grad_pooled, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> ksize, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> kstride)</td></tr>
<tr class="memdesc:a9122d3e29b798bf56ea541a1c8a640f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">unpooling gradient for 4D, backprop gradient value back, revserse operation of pooling  <a href="#a9122d3e29b798bf56ea541a1c8a640f3">More...</a><br/></td></tr>
<tr class="separator:a9122d3e29b798bf56ea541a1c8a640f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e7f32ca9f8a8fcd7382dcd4c59e1f3"><td class="memTemplParams" colspan="2">template&lt;typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:ab0e7f32ca9f8a8fcd7382dcd4c59e1f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1PaddingExp.html">PaddingExp</a>&lt; SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a><br class="typebreak"/>
&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#ab0e7f32ca9f8a8fcd7382dcd4c59e1f3">pad</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> pad)</td></tr>
<tr class="memdesc:ab0e7f32ca9f8a8fcd7382dcd4c59e1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">padding expression, pad a image with zeros on boundaries, padding affects shape[0], and shape[1]  <a href="#ab0e7f32ca9f8a8fcd7382dcd4c59e1f3">More...</a><br/></td></tr>
<tr class="separator:ab0e7f32ca9f8a8fcd7382dcd4c59e1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cd138aabb72f903918cda2fb57a841"><td class="memTemplParams" colspan="2">template&lt;typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:a09cd138aabb72f903918cda2fb57a841"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1CroppingExp.html">CroppingExp</a>&lt; SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a><br class="typebreak"/>
&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a09cd138aabb72f903918cda2fb57a841">crop</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src, <a class="el" href="structmshadow_1_1Shape.html">Shape</a>&lt; 2 &gt; oshape)</td></tr>
<tr class="memdesc:a09cd138aabb72f903918cda2fb57a841"><td class="mdescLeft">&#160;</td><td class="mdescRight">revserse operationg of padding, cut off boundaries, crop output from center of input  <a href="#a09cd138aabb72f903918cda2fb57a841">More...</a><br/></td></tr>
<tr class="separator:a09cd138aabb72f903918cda2fb57a841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0bb1eb0ca316ff5814f0923efc218e"><td class="memTemplParams" colspan="2">template&lt;typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:afc0bb1eb0ca316ff5814f0923efc218e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1CroppingExp.html">CroppingExp</a>&lt; SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a><br class="typebreak"/>
&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#afc0bb1eb0ca316ff5814f0923efc218e">crop</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src, <a class="el" href="structmshadow_1_1Shape.html">Shape</a>&lt; 2 &gt; oshape, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> start_height, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> start_width)</td></tr>
<tr class="memdesc:afc0bb1eb0ca316ff5814f0923efc218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as crop, but can specify starting position to do cropping  <a href="#afc0bb1eb0ca316ff5814f0923efc218e">More...</a><br/></td></tr>
<tr class="separator:afc0bb1eb0ca316ff5814f0923efc218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af619036bb39914372b176f4037baae98"><td class="memTemplParams" colspan="2">template&lt;typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:af619036bb39914372b176f4037baae98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1MirroringExp.html">MirroringExp</a>&lt; SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a><br class="typebreak"/>
&lt; SrcExp &gt;::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#af619036bb39914372b176f4037baae98">mirror</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src)</td></tr>
<tr class="memdesc:af619036bb39914372b176f4037baae98"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirroring expression, mirror images in width  <a href="#af619036bb39914372b176f4037baae98">More...</a><br/></td></tr>
<tr class="separator:af619036bb39914372b176f4037baae98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3c17fd54e168ce669aeddb1011b3c6"><td class="memTemplParams" colspan="2">template&lt;typename Reducer , typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:aff3c17fd54e168ce669aeddb1011b3c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1ChannelPoolingExp.html">ChannelPoolingExp</a>&lt; Reducer, <br class="typebreak"/>
SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt; SrcExp &gt;<br class="typebreak"/>
::kDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#aff3c17fd54e168ce669aeddb1011b3c6">chpool</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;src, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> nsize)</td></tr>
<tr class="memdesc:aff3c17fd54e168ce669aeddb1011b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel pooling, do reduction over (local nearby) channels, used to implement local response normalization  <a href="#aff3c17fd54e168ce669aeddb1011b3c6">More...</a><br/></td></tr>
<tr class="separator:aff3c17fd54e168ce669aeddb1011b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe356426ed7cfd82ad6f996816469729"><td class="memTemplParams" colspan="2">template&lt;typename Device &gt; </td></tr>
<tr class="memitem:afe356426ed7cfd82ad6f996816469729"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1Broadcast1DExp.html">Broadcast1DExp</a>&lt; Device, 2, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#afe356426ed7cfd82ad6f996816469729">repmat</a> (const <a class="el" href="structmshadow_1_1Tensor.html">Tensor</a>&lt; Device, 1 &gt; &amp;src, <a class="el" href="namespacemshadow.html#a6b28b89656a269ae8d5188964c3b3adb">index_t</a> nrow)</td></tr>
<tr class="memdesc:afe356426ed7cfd82ad6f996816469729"><td class="mdescLeft">&#160;</td><td class="mdescRight">a expression that replicate a 1 dimension tensor for nrow times  <a href="#afe356426ed7cfd82ad6f996816469729">More...</a><br/></td></tr>
<tr class="separator:afe356426ed7cfd82ad6f996816469729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3832b7e41d3396f6f8581818db2a8c5d"><td class="memTemplParams" colspan="2">template&lt;typename SrcExp , int etype&gt; </td></tr>
<tr class="memitem:a3832b7e41d3396f6f8581818db2a8c5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt; SrcExp, <br class="typebreak"/>
<a class="el" href="structmshadow_1_1red_1_1sum.html">red::sum</a>, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemshadow_1_1expr.html#a3832b7e41d3396f6f8581818db2a8c5d">sum_rows</a> (const <a class="el" href="structmshadow_1_1expr_1_1Exp.html">Exp</a>&lt; SrcExp, etype &gt; &amp;exp)</td></tr>
<tr class="memdesc:a3832b7e41d3396f6f8581818db2a8c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">a expression that sum over rows of a matrix  <a href="#a3832b7e41d3396f6f8581818db2a8c5d">More...</a><br/></td></tr>
<tr class="separator:a3832b7e41d3396f6f8581818db2a8c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98733792aeb5621c6c5a5d4b3963c7aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98733792aeb5621c6c5a5d4b3963c7aa"></a>
template&lt;typename OP , typename TA , typename TB , int etype&gt; </td></tr>
<tr class="memitem:a98733792aeb5621c6c5a5d4b3963c7aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan.html">SSEPlan</a>&lt; <a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, TA, <br class="typebreak"/>
TB, etype &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeSSEPlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt; OP, TA, TB, etype &gt; &amp;e)</td></tr>
<tr class="separator:a98733792aeb5621c6c5a5d4b3963c7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430e8a21a7f3f87cdc837c5d28f3ee0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a430e8a21a7f3f87cdc837c5d28f3ee0d"></a>
<a class="el" href="classmshadow_1_1expr_1_1SSEPlan.html">SSEPlan</a>&lt; <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeSSEPlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1ScalarExp.html">ScalarExp</a> &amp;e)</td></tr>
<tr class="separator:a430e8a21a7f3f87cdc837c5d28f3ee0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dcb8f184d7a546456ff801cdd7ae2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46dcb8f184d7a546456ff801cdd7ae2d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46dcb8f184d7a546456ff801cdd7ae2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan.html">SSEPlan</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeSSEPlan</b> (const <a class="el" href="classmshadow_1_1expr_1_1ContainerExp.html">ContainerExp</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="separator:a46dcb8f184d7a546456ff801cdd7ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c0127dbef7962e1c228e25b50f63bc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a77c0127dbef7962e1c228e25b50f63bc"></a>
template&lt;typename T , int dim&gt; </td></tr>
<tr class="memitem:a77c0127dbef7962e1c228e25b50f63bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan.html">SSEPlan</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeSSEPlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1MakeTensorExp.html">MakeTensorExp</a>&lt; T, <a class="el" href="structmshadow_1_1cpu.html">cpu</a>, dim &gt; &amp;e)</td></tr>
<tr class="separator:a77c0127dbef7962e1c228e25b50f63bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2905b89d9da99c0797ef381c6ca1add8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2905b89d9da99c0797ef381c6ca1add8"></a>
template&lt;typename OP , typename TA , int etype&gt; </td></tr>
<tr class="memitem:a2905b89d9da99c0797ef381c6ca1add8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmshadow_1_1expr_1_1SSEPlan.html">SSEPlan</a>&lt; <a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a>&lt; OP, TA, <br class="typebreak"/>
etype &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeSSEPlan</b> (const <a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a>&lt; OP, TA, etype &gt; &amp;e)</td></tr>
<tr class="separator:a2905b89d9da99c0797ef381c6ca1add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace for abstract expressions and expressions template, have no dependecy on <a class="el" href="tensor_8h.html" title="header file of tensor data structure and functions covention: this lib requires explicit memory alloc...">tensor.h</a>, These data structure takes no charge in computations, they are only used to define operations and represent expression in a symbolic way </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adbd375ac36285f66ca4b3b77dfa93bab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimcast, typename Device , int dimdst&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1Broadcast1DExp.html">Broadcast1DExp</a>&lt;Device,dimdst,dimcast&gt; mshadow::expr::broadcast </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; Device, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&lt; dimdst &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a expression that replicate a 1 dimension tensor in dimension dimcast </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="structmshadow_1_1Tensor_3_01Device_00_011_01_4.html">Tensor&lt;Device,1&gt;</a>: shape[0] </td></tr>
    <tr><td class="paramname">shape</td><td>shape of output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a expresion with type Tensor&lt;Device,dimdst&gt; </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimcast</td><td>target dimension where the 1D tensor will be broadcasted </td></tr>
    <tr><td class="paramname">Device</td><td>which device it lies </td></tr>
    <tr><td class="paramname">dimdst</td><td>dimension of destination tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff3c17fd54e168ce669aeddb1011b3c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reducer , typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1ChannelPoolingExp.html">ChannelPoolingExp</a>&lt;Reducer,SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim &gt; mshadow::expr::chpool </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>nsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>channel pooling, do reduction over (local nearby) channels, used to implement local response normalization </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source data </td></tr>
    <tr><td class="paramname">nsize</td><td>neighbor size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression of pooled result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reducer</td><td>reducer type </td></tr>
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09cd138aabb72f903918cda2fb57a841"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1CroppingExp.html">CroppingExp</a>&lt;SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim&gt; mshadow::expr::crop </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>oshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>revserse operationg of padding, cut off boundaries, crop output from center of input </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>original image batches </td></tr>
    <tr><td class="paramname">oshape</td><td>output shape to be cropped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression corresponding to padded result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc0bb1eb0ca316ff5814f0923efc218e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1CroppingExp.html">CroppingExp</a>&lt;SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim&gt; mshadow::expr::crop </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>oshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>start_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>start_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same as crop, but can specify starting position to do cropping </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>original image batches </td></tr>
    <tr><td class="paramname">oshape</td><td>output shape to be cropped </td></tr>
    <tr><td class="paramname">start_height</td><td>start height position to do cropping </td></tr>
    <tr><td class="paramname">start_width</td><td>start width position to do cropping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression corresponding to padded result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a694976236618fc4e22c5ccd752981589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , typename TA , typename TB , int ta, int tb&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1BinaryMapExp.html">BinaryMapExp</a>&lt;OP,TA,TB, (ta|tb|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt; mshadow::expr::F </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; TA, ta &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Exp&lt; TB, tb &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>short hand for MakeExp, usage F&lt;op&gt;(lhs, rhs). create a binary operation expression </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">binary</td><td>operator </td></tr>
    <tr><td class="paramname">TA</td><td>lhs expression </td></tr>
    <tr><td class="paramname">ta</td><td>lhs expression type </td></tr>
    <tr><td class="paramname">TB</td><td>rhs expression </td></tr>
    <tr><td class="paramname">tb</td><td>rhs expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemshadow_1_1op.html" title="operations for algorithm ">mshadow::op</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af7bd250e50a00def5ea9231596645044"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , typename TA , int ta&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1UnaryMapExp.html">UnaryMapExp</a>&lt;OP,TA,(ta|<a class="el" href="namespacemshadow_1_1expr_1_1type.html#aa700f17fa964d262266efd336d5c50ca">type::kMapper</a>) &gt; mshadow::expr::F </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; TA, ta &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>short hand for MakeExp, usage F&lt;op&gt;(src), create a unary operation expression </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">operator</td><td></td></tr>
    <tr><td class="paramname">TA</td><td>source expression </td></tr>
    <tr><td class="paramname">ta</td><td>source expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemshadow_1_1op.html" title="operations for algorithm ">mshadow::op</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af619036bb39914372b176f4037baae98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1MirroringExp.html">MirroringExp</a>&lt;SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim&gt; mshadow::expr::mirror </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mirroring expression, mirror images in width </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>original image batches </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression corresponding to mirrored result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0e2eb3b1d959701ac1740a5d98142a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Device , int dstdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1PackColToPatchXExp.html">PackColToPatchXExp</a>&lt;Device,dstdim&gt; mshadow::expr::pack_col2patch </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; Device, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&lt; dstdim &gt;&#160;</td>
          <td class="paramname"><em>imshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>psize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>pstride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverse operation of pack_col2patch, can be used to implement deconvolution </p>
<dl class="section return"><dt>Returns</dt><dd>packed img expression </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>source matrix </td></tr>
    <tr><td class="paramname">imshape</td><td>shape of target img </td></tr>
    <tr><td class="paramname">psize</td><td>height and width of each patch </td></tr>
    <tr><td class="paramname">pstride</td><td>stride of each patch </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Device</td><td>the Device where input data lies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0e7f32ca9f8a8fcd7382dcd4c59e1f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1PaddingExp.html">PaddingExp</a>&lt;SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim&gt; mshadow::expr::pad </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>pad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>padding expression, pad a image with zeros on boundaries, padding affects shape[0], and shape[1] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>original image batches </td></tr>
    <tr><td class="paramname">pad</td><td>padding size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression corresponding to padded result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcba0398ae5e8897b0803e80fa4df7ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reducer , typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1PoolingExp.html">PoolingExp</a>&lt;Reducer,SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim &gt; mshadow::expr::pool </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>kstride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pooling subregion results together </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image, shape[3]: batch, shape[2]: channel shape[1]: height shape[0]:width </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel size </td></tr>
    <tr><td class="paramname">kstride</td><td>stride for each kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression of pooled result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reducer</td><td>reducer type </td></tr>
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9ebccc287df237b904ad73ea19b6eb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reducer , typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1PoolingExp.html">PoolingExp</a>&lt;Reducer,SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim &gt; mshadow::expr::pool </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>pshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>kstride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same as pool, except the output shape is specified by pshape </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">pshape</td><td>ouput shape </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel size </td></tr>
    <tr><td class="paramname">kstride</td><td>stride for each kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression of pooled result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reducer</td><td>reducer type </td></tr>
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe356426ed7cfd82ad6f996816469729"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Device &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1Broadcast1DExp.html">Broadcast1DExp</a>&lt;Device,2,0&gt; mshadow::expr::repmat </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; Device, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>nrow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a expression that replicate a 1 dimension tensor for nrow times </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="structmshadow_1_1Tensor_3_01Device_00_011_01_4.html">Tensor&lt;Device,1&gt;</a>: shape[0] </td></tr>
    <tr><td class="paramname">nrow</td><td>number of rows to replicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a expresion with type <a class="el" href="structmshadow_1_1Tensor.html">Tensor&lt;Device,2&gt;</a> shape[0], shape[1] = nrow </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Device</td><td>which device it lies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a65c95414492a64bb51dbd0710fd9c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcExp , int etype, int dimdst&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1ReshapeExp.html">ReshapeExp</a>&lt; SrcExp,dimdst, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim &gt; mshadow::expr::reshape </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape&lt; dimdst &gt;&#160;</td>
          <td class="paramname"><em>oshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a expression that reshapes a tensor to another shape </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Tensor&lt;Device,dimsrc&gt;: </td></tr>
    <tr><td class="paramname">oshape</td><td>target shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a expresion with type Tensor&lt;Device,dimdst&gt; </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>source expression type </td></tr>
    <tr><td class="paramname">dimdst</td><td>target dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3832b7e41d3396f6f8581818db2a8c5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt;SrcExp, <a class="el" href="structmshadow_1_1red_1_1sum.html">red::sum</a>, 0 &gt; mshadow::expr::sum_rows </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>exp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a expression that sum over rows of a matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>input expression that must be a matrix <a class="el" href="structmshadow_1_1Tensor.html" title="general tensor ">Tensor</a>&lt;?,2&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a expresion with type <a class="el" href="structmshadow_1_1Tensor_3_01Device_00_011_01_4.html">Tensor&lt;Device,1&gt;</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SrcExp</td><td>expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c28af37c1dd0b2efee2bb896d628803"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimkeep, typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1ReduceTo1DExp.html">ReduceTo1DExp</a>&lt;SrcExp, <a class="el" href="structmshadow_1_1red_1_1sum.html">red::sum</a>, dimkeep &gt; mshadow::expr::sumall_except_dim </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>exp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a sum over all dimensions, except dimkeep </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>input expression that must be a matrix <a class="el" href="structmshadow_1_1Tensor.html" title="general tensor ">Tensor</a>&lt;?,2&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a expresion with type <a class="el" href="structmshadow_1_1Tensor_3_01Device_00_011_01_4.html">Tensor&lt;Device,1&gt;</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimkeep</td><td>the dimension that will be kept </td></tr>
    <tr><td class="paramname">SrcExp</td><td>expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad222b7d78cd6b1e9fe4fe31fe837d88a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int a1, int a2, typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1SwapAxisExp.html">SwapAxisExp</a>&lt; SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim, a1,a2&gt; mshadow::expr::swapaxis </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a expression that reshapes a tensor to another shape </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Tensor&lt;Device,dimsrc&gt;: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a expresion with type Tensor&lt;Device,dimdst&gt; </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">a1</td><td>smaller dimension to be swapped </td></tr>
    <tr><td class="paramname">a2</td><td>larger dimension to be swapped </td></tr>
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>source expression type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91f2f6a31c6d0fdfcf522e8928f3ce35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcExp , int etype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1UnpackPatchToColXExp.html">UnpackPatchToColXExp</a>&lt;SrcExp, <a class="el" href="structmshadow_1_1expr_1_1ExpInfo.html">ExpInfo</a>&lt;SrcExp&gt;::kDim &gt; mshadow::expr::unpack_patch2col </td>
          <td>(</td>
          <td class="paramtype">const Exp&lt; SrcExp, etype &gt; &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>psize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>pstride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unpack local (overlap) patches of image to column of mat, can be used to implement convolution after getting unpacked mat, we can use: output = dot( weight, mat ) to get covolved results, the relations: </p>
<p>weight; shape[1]: out_channel, shape[0]: ichannel*psize*psize output; shape[1]: out_channel, shape[0]: out_height*out_width * num_of_images out_height = ( in_height - psize ) / pstride + 1, this means we pad inperfect patch with 0 out_width = ( in_width - psize ) / pstride + 1</p>
<dl class="section return"><dt>Returns</dt><dd>mat target matrix; shape[1]: in_channel*psize*psize shape[0]: out_height*out_width * num_of_images </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>source image; shape[2]: in_channels, shape[1]: in_height, shape[0]: in_width, can be 3D or 4D tensor(multiple images) </td></tr>
    <tr><td class="paramname">psize</td><td>height and width of each patch </td></tr>
    <tr><td class="paramname">pstride</td><td>stride of each patch </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SrcExp</td><td>source expression </td></tr>
    <tr><td class="paramname">etype</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9122d3e29b798bf56ea541a1c8a640f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reducer , typename Device &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmshadow_1_1expr_1_1UnPoolingExp.html">UnPoolingExp</a>&lt;Reducer, Device&gt; mshadow::expr::unpool </td>
          <td>(</td>
          <td class="paramtype">const Tensor&lt; Device, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Device, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_pooled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor&lt; Device, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_pooled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&#160;</td>
          <td class="paramname"><em>kstride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unpooling gradient for 4D, backprop gradient value back, revserse operation of pooling </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_src</td><td>source input, corresponds to src in pooling </td></tr>
    <tr><td class="paramname">data_pooled</td><td>result of pooled data, corresponds to result of pooling </td></tr>
    <tr><td class="paramname">grad_pooled</td><td>gradient data of pooled part, to be propgate down </td></tr>
    <tr><td class="paramname">ksize</td><td>kernel size </td></tr>
    <tr><td class="paramname">kstride</td><td>stride for each kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression corresponding to unpooled 4D <a class="el" href="structmshadow_1_1Tensor.html" title="general tensor ">Tensor</a>, storing backproped gradient </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Reducer</td><td>reducer type </td></tr>
    <tr><td class="paramname">Device</td><td>device where data lies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 7 2015 17:15:38 for Apache SINGA by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
